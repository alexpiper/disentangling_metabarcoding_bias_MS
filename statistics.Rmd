---
title: "Disentangling bias for non-destructive insect metabarcoding."
subtitle: "Statistical analysis"
author: "A.M. Piper"
date: "`r Sys.Date()`"
output: 
  html_document:
    highlighter: null
    theme: "flatly"
    code_download: true
    toc: true
    toc_float: 
      collapsed: false
      smooth_scroll: true
    df_print: paged    
  pdf_document: default
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval=FALSE)
```

## Load packages
```{r load packages}
#Set required packages
.cran_packages <- c("tidyverse",
                    "tidymodels",
                    "janitor",
                    "vip",
                    "patchwork", 
                    "vegan", 
                    "seqinr",
                    "ape", 
                    "RColorBrewer",
                    "devtools",
                    "ggthemes",
                    "phangorn",
                    "ape",
                    "ggtree",
                    "ggcorrplot",
                    "GGally",
                    "ggstance",
                    "ggdist",
                    "distributional")

.bioc_packages <- c("dada2",
                    "phyloseq", 
                    "DECIPHER",
                    "Biostrings",
                    "ShortRead", 
                    "ALDEx2")
.inst <- .cran_packages %in% installed.packages()
if(any(!.inst)) {
   install.packages(.cran_packages[!.inst])
}
.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)) {
  if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
  BiocManager::install(.bioc_packages[!.inst], ask = F)
}
sapply(c(.cran_packages,.bioc_packages), require, character.only = TRUE)

# Github packages
devtools::install_github("mikemc/metacal")
devtools::install_github("alexpiper/taxreturn")
devtools::install_github("easystats/report")

library(metacal)
library(taxreturn)
library(report)

#Source helper functions
source("R/helper_functions.R")

# Set a taxon colour scheme - Also use the order here to order species on later plots
colours.taxon <- c(
  "Carpophilus_davidsoni" = "#9AD378",
  "Carpophilus_truncatus" = "#3EA534",  
  "Bactrocera_tryoni" = "#000000",
  "Bradysia_nr.ocellaris" = "#FFFF00",
  "Drosophila_hydei" = "#F26B6B"  ,
  "Drosophila_melanogaster" = "#E52823",
  "Drosophila_simulans" = "#FE9C32",
  "Scaptodrosophila_lativittata" = "#800080",
  "Acizzia_alternata" = "#A6CEE3",
  "Acizzia_solanicola" = "#438FC0",
  "Acizzia_sp" = "#000080", 
  "Diuraphis_noxia" = "#B29C71",
  "Metopolophium_dirhodum" = "#CAB2D6",
  "Rhopalosiphum_padi" = "#FF00FF",
  "Aphidius_colemani" = "#808080",
  "Lysiphlebus_testaceipes" = "#F08C3A"
) 

# Make a version without underscores
colours.taxon2 <- colours.taxon
names(colours.taxon2) <- names(colours.taxon) %>% str_replace("_", " ")

#Source themes
source('R/themes.R')
```

# Run summary statistics

```{R phyloseq}
# Read in new counts
ps <- readRDS("output/rds/ps.rds")

# Spread of reads between protocols
pre_filt <- speedyseq::psmelt(ps) %>%
  mutate(sample = sample_name %>% str_remove("_.*$"),
         taxon = species %>% str_replace(" ", "_")) %>%
  dplyr::select(OTU, taxon, sample_id, Abundance, sample, fcid, target_subfragment = pcr_primers, extraction_method) %>%
  filter(!str_detect(sample_id, "_1_[0-9]0_")) %>% #Check this with francesco!
  mutate(sample_id=case_when(
    fcid=="CGK9B" ~ paste0(sample, "_1"),
    fcid=="CJL7D" ~ paste0(sample, "_2")
  ),
  mixture_type = case_when(
                  str_detect(sample, "^I[1-4]") ~ "QuickExtract",
                  str_detect(sample, "^I[5-8]") ~ "DNEasy",
                  str_detect(sample, "PCRpool") ~ "PCR",
                  str_detect(sample, "^D[1-8]") ~ "DNA"
                  ))  %>%
  filter(Abundance > 0, !is.na(mixture_type))

# Calculate classified and unclassified ASV's
pre_filt %>%
  mutate(classified = !is.na(taxon)) %>%
  group_by(classified) %>%
  summarise(abundance = sum(Abundance), number = n_distinct(OTU))

# Total reads per FCID
pre_filt %>%
  group_by(fcid) %>%
  summarise(sum = sum(Abundance))

# Total reads per sample_id
pre_filt %>%
  group_by(fcid, sample_id) %>%
  summarise(sum = sum(Abundance)) %>%
  ggplot(aes(x = sample_id, y = sum))+
  geom_col()+
  facet_grid(~fcid, scales="free", drop=TRUE) +
  base_theme

# Total ASVs
pre_filt %>%
  summarise(ASVs = n_distinct(OTU))

# Spread of Reads pre filtering
pre_filt %>%
  group_by(sample_id) %>%
  summarise(Abundance = sum(Abundance), fcid)%>%
  ungroup() %>%
  summarise(mean = mean(Abundance), 
            se = sd(Abundance)/sqrt(length(Abundance)),
            max = max(Abundance),
            min = min(Abundance))

# Spread of OTUS pre filtering
pre_filt %>%
  group_by(sample_id) %>%
  summarise(Abundance =  n_distinct(OTU), fcid)%>%
  ungroup() %>%
  summarise(mean = mean(Abundance), 
            se = sd(Abundance)/sqrt(length(Abundance)),
            max = max(Abundance),
            min = min(Abundance))

# Anova and pairwise comparisons of ASVs

# Rarefy to even depths
ps_rare <- rarefy_even_depth(ps, sample.size = min(100000),
  rngseed = 666, replace = TRUE, trimOTUs = TRUE, verbose = TRUE)

rarestats <- speedyseq::psmelt(ps) %>%
  mutate(sample = sample_name %>% str_remove("_.*$"),
         taxon = species %>% str_replace(" ", "_")) %>%
  dplyr::select(OTU, taxon, sample_id, Abundance, sample, fcid, target_subfragment = pcr_primers, extraction_method) %>%
  filter(!str_detect(sample_id, "_1_[0-9]0_")) %>% #Check this with francesco!
  mutate(sample_id=case_when(
    fcid=="CGK9B" ~ paste0(sample, "_1"),
    fcid=="CJL7D" ~ paste0(sample, "_2")
  ),
  mixture_type = case_when(
                  str_detect(sample, "^I[1-4]") ~ "QuickExtract",
                  str_detect(sample, "^I[5-8]") ~ "DNEasy",
                  str_detect(sample, "PCRpool") ~ "PCR",
                  str_detect(sample, "^D[1-8]") ~ "DNA"
                  ))  %>%
  filter(Abundance > 0, !is.na(mixture_type))

asv_rare_pre <- rarestats %>%
  dplyr::filter(Abundance > 0) %>%
  group_by(sample_id, mixture_type, fcid) %>%
  summarise(counts = n_distinct(OTU)) %>%
  ungroup() 

asv_rare_pre %>%
  group_by(mixture_type)%>%
  summarise(mean = mean(counts), 
            se = sd(counts)/sqrt(length(counts)),
            max = max(counts),
            min = min(counts))

#ANOVA
report(aov(counts ~mixture_type, data=asv_rare_pre))
broom::tidy(TukeyHSD(aov(counts ~mixture_type, data=asv_rare_pre))) 

# Remove run 2 quickextract
rarestats2 <- speedyseq::psmelt(ps) %>%
  mutate(sample = sample_name %>% str_remove("_.*$"),
         taxon = species %>% str_replace(" ", "_")) %>%
  dplyr::select(OTU, taxon, sample_id, Abundance, sample, fcid, target_subfragment = pcr_primers, extraction_method) %>%
  filter(!str_detect(sample_id, "_1_[0-9]0_")) %>% #Check this with francesco!
  mutate(sample_id=case_when(
    fcid=="CGK9B" ~ paste0(sample, "_1"),
    fcid=="CJL7D" ~ paste0(sample, "_2")
  ),
  mixture_type = case_when(
                  str_detect(sample, "^I[1-4]") ~ "QuickExtract",
                  str_detect(sample, "^I[5-8]") ~ "DNEasy",
                  str_detect(sample, "PCRpool") ~ "PCR",
                  str_detect(sample, "^D[1-8]") ~ "DNA"
                  ))  %>%
  filter(Abundance > 0, !is.na(mixture_type)) %>%
  dplyr::filter(!(mixture_type=="QuickExtract" & fcid=="CJL7D")) 

# Prefilt
asv_rare_pre2 <- rarestats2 %>%
  dplyr::filter(Abundance > 0) %>%
  group_by(sample_id, mixture_type, fcid, target_subfragment) %>%
  summarise(counts = n_distinct(OTU)) %>%
  ungroup() 

asv_rare_pre2 %>%
  group_by(mixture_type)%>%
  summarise(mean = mean(counts), 
            se = sd(counts)/sqrt(length(counts)),
            max = max(counts),
            min = min(counts))

#ANOVA

#Mixture type
report(aov(counts ~mixture_type, data=asv_rare_pre2))
broom::tidy(TukeyHSD(aov(counts ~mixture_type, data=asv_rare_pre2))) 

#Primers
report(aov(counts ~target_subfragment, data=asv_rare_pre2))
broom::tidy(TukeyHSD(aov(counts ~target_subfragment, data=asv_rare_pre2))) 

# Post filt
asv_rare_post <- rarestats2 %>%
  filter(!is.na(taxon)) %>%
  dplyr::filter(Abundance > 0) %>%
  group_by(sample_id, mixture_type, fcid, target_subfragment) %>%
  summarise(counts = n_distinct(OTU)) %>%
  ungroup() 

asv_rare_post %>%
  group_by(mixture_type)%>%
  summarise(mean = mean(counts), 
            se = sd(counts)/sqrt(length(counts)),
            max = max(counts),
            min = min(counts))

#ANOVA

# Mixture type
report(aov(counts ~mixture_type, data=asv_rare_post))
broom::tidy(TukeyHSD(aov(counts ~mixture_type, data=asv_rare_post))) 

#Primers
report(aov(counts ~target_subfragment, data=asv_rare_post))
broom::tidy(TukeyHSD(aov(counts ~target_subfragment, data=asv_rare_post))) 

#Where is hte higher quickextract coming from
haplotypes <- rarestats2 %>%
  filter(!is.na(taxon)) %>%
  group_by(mixture_type, target_subfragment, taxon) %>%
  summarise(haplo = n_distinct(OTU)) %>%
  pivot_wider(names_from = mixture_type, values_from=haplo)


# Filter out unclassified and agglomerate species
ps0 <- ps %>%
  subset_taxa(
    phylum == "Arthropoda"
  ) %>%
  filter_taxa(function(x) mean(x) > 0, TRUE) %>%
  prune_samples(sample_sums(.) >0 , .) %>%
  tax_glom("species")

saveRDS(ps0, "output/rds/ps_filtered.rds")

```


```{r}
ps0 <- readRDS("output/rds/ps_filtered.rds")

ps_data <- ps0 %>%
  speedyseq::psmelt() %>%
  mutate(sample = sample_name %>% str_remove("_.*$"),
         taxon = species %>% str_replace(" ", "_")) %>%
  dplyr::select(taxon, sample_id, Abundance, sample, fcid, target_subfragment = pcr_primers) %>%
  filter(Abundance > 0, !is.na(taxon)) %>%
  filter(!str_detect(sample_id, "_1_[0-9]0_")) %>% 
  mutate(sample_id=case_when(
    fcid=="CGK9B" ~ paste0(sample, "_1"),
    fcid=="CJL7D" ~ paste0(sample, "_2")
  ),
  mixture_type = case_when(
                  str_detect(sample, "^I[1-4]") ~ "QuickExtract",
                  str_detect(sample, "^I[5-8]") ~ "DNEasy",
                  str_detect(sample, "PCRpool") ~ "PCR",
                  str_detect(sample, "^D[1-8]") ~ "DNA"
                  )) %>%
  mutate(taxon = taxon %>% 
           str_replace("nr.dimidiatus", "truncatus") %>%
           str_replace("Psyllid_sp", "Acizzia_sp")) %>%
  mutate(target_subfragment = target_subfragment %>% str_replace("fwhf2-HexCOIR4", "fwhF2-HexCOIR4"))

counts <- read_csv("sample_data/expected_counts.csv") %>%
  dplyr::mutate(taxon = taxon %>%
                  str_replace("hydeii", "hydei") %>%
                  str_replace_all(" ", "_") %>%
                  str_replace("dimidiatus", "truncatus")%>%
                  str_replace("Bradysia_ocellaris", "Bradysia_nr.ocellaris") %>%
                  str_replace("Psyllid_sp", "Acizzia_sp")
                  ) %>%
  dplyr::select(sample, taxon, expected, num_species) %>%
  left_join(ps_data) %>%
  group_by(sample_id) %>%
  filter(!is.na(fcid)) %>%
  mutate(prop = Abundance) %>%
  mutate_at(c("prop"),  ~ . / sum(., na.rm = TRUE) ) %>%
  ungroup() %>%
  dplyr::rename(observed = prop, count = Abundance) %>%
  dplyr::mutate(observed = replace_na(observed, 0),
                count = replace_na(count, 0),
                run = sample_id %>% str_remove("^.*_"))

# Check all are proportions  
counts %>%
  group_by(sample, run) %>%
  summarise(exp = sum(expected), obs = sum(observed), count = sum(count))

# N unique species and samples
 counts %>%
  summarise(n_samples = n_distinct(sample), n_sequenced_samples = n_distinct(sample_id))

# Spread of reads
counts %>%
  group_by(sample_id) %>%
  summarise(exp_prop = sum(expected), obs_prop = sum(observed), Abundance = sum(count), run) %>%
  ungroup() %>%
  #group_by(run)%>%
  summarise(mean = mean(Abundance), 
            se = sd(Abundance)/sqrt(length(Abundance)),
            max = max(Abundance),
            min = min(Abundance),
            exp_prop = mean(exp_prop),
            obs_prop = mean(obs_prop))

```

## Add species traits

```{r biomass transform}
traits <- readxl::read_excel("sample_data/biomass_and_hardness_v2.xlsx", skip = 1)  %>%
  janitor::clean_names() %>%
  dplyr::select(taxon = species, biomass_mm3 = volume_mm3, surface_mm2, exoskeleton = hardness) %>%
  filter(!is.na(taxon)) %>%
  dplyr::mutate(taxon = taxon %>%
                  str_replace("C\\.", "Carpophilus") %>%
                  str_replace("D\\.", "Drosophila") %>%
                  str_replace("A\\.", "Acizzia") %>%
                  str_replace("hydeii", "hydei") %>%
                  str_replace_all(" ", "_") %>%
                  str_remove_all("\\.")%>%
                  str_replace("nr_dimidiatis", "truncatus")%>%
                  str_replace("Bradysia_nr_ocellaris", "Bradysia_nr.ocellaris")
                  ) %>%
  dplyr::mutate(exoskeleton = as.numeric(exoskeleton))

# Plot measured traits
traits %>%
  pivot_longer(-taxon, 
               names_to = "trait",
               values_to = "value") %>%
  ggplot(aes(x=taxon, y=value)) + 
  geom_col() +
  facet_grid(~trait) + 
  coord_flip() +
  scale_fill_brewer(palette="Paired")

#Check for differencess in taxon names
setdiff(traits$taxon, counts$taxon)
setdiff(counts$taxon, traits$taxon)


# create a good pseudocount
# this was chosen to give a proportion that is less than 1 divided by the maximum sample read depth
# and so is expected to have negligible effect on the resulting estimates.
pseudocount <- counts %>% 
  group_by(sample_id) %>%
  summarise(sum = sum(count)) %>%
  pull(sum)%>% 
  max() %>% 
  {1 / .}

# Join tables together
joint <- counts %>%
  left_join(traits%>%
            mutate(taxon = taxon %>% str_replace("hydeii", "hydei")), by="taxon") %>%
  dplyr::mutate(exp_individuals = expected,
                exp_individuals = expected * biomass_mm3) %>%
  group_by(sample_id) %>%
    mutate_at(vars(exp_individuals, exp_individuals, observed), ~ . / sum(.) ) %>% #Convert back to proportions
  ungroup() %>%
  mutate(observed0 = (count + pseudocount) * (expected > 0)) %>% #Add a pseudocount
  mutate(err_biomass = observed0 / exp_individuals,
         err_individuals = observed0 / exp_individuals) %>%
  ungroup() %>%
 group_by(sample_id) %>%
 group_modify(~{
    clr_denom_bio <- .x %>%
     pull(err_biomass) %>%
     gm_mean()
   clr_denom_ind <- .x %>%
     pull(err_individuals) %>%
     gm_mean()
   .x %>%
     mutate(err_biomass = log(err_biomass / clr_denom_bio),
            err_individuals = log(err_individuals / clr_denom_ind))
 }) %>%
  mutate(exoskeleton= case_when(
           exoskeleton == 1 ~ "soft",
           exoskeleton == 2 ~ "medium",
           exoskeleton == 3 ~ "hard"
         ))  %>%
    mutate(exoskeleton = factor(exoskeleton, levels=c( "soft", "hard", "medium") ))

# Check if any werent properly joined
table(is.na(joint$exp_individuals))

# Plot expected individuals vs expected biomass
gg.p1 <- joint %>%
  dplyr::filter(target_subfragment=="fwhF2-fwhR2n") %>% #Filter to primer1
  dplyr::select(sample_id, taxon, observed, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample_id", "taxon", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  ggplot(aes(x=sample_id, y=value, fill=taxon)) +
  geom_col(position="stack") +
  facet_grid(type~mixture_type, scales="free_x") +
  scale_fill_manual(values = colours.taxon) +
  base_theme +
  theme(axis.text.x = element_text(angle=45, hjust=1),
        legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  labs(x="Sample", y="Relative abundance", title="fwhF2 - fwhR2n")

gg.p2 <- joint %>%
  dplyr::filter(target_subfragment =="fwhF2-HexCOIR4") %>% 
  dplyr::select(sample_id, taxon, observed, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample_id", "taxon", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  ggplot(aes(x=sample_id, y=value, fill=taxon)) +
  geom_col(position="stack") +
  facet_grid(type~mixture_type, scales="free_x") +
  scale_fill_manual(values = colours.taxon) +
  base_theme +
  theme(axis.text.x = element_text(angle=45, hjust=1),
        legend.position = "bottom") +
  scale_y_continuous(labels = scales::percent) +
  labs(x="Sample", y="Relative abundance", title="fwhF2 - HexCOIR4")

gg.p1 + gg.p2
```

## Add sequence traits

```{r sequence traits}
# Get PHMM of full folmer region
coi_model <- readRDS("reference/folmer_fullength_model.rds")

primers <- tribble(
  ~Fname, ~Fprimer, ~Rname, ~Rprimer,
  "fwhF2",  "GGDACWGGWTGAACWGTWTAYCCHCC", "fwhR2n","GTRATWGCHCCDGCTARWACWGG",
  "fwhF2",  "GGDACWGGWTGAACWGTWTAYCCHCC", "HexCOIR4", "TATDGTRATDGCHCCNGC", 
  ) %>%
    left_join(.$Fprimer %>% unique() %>% purrr::map(get_binding_position, coi_model, tryrc = TRUE, min_score=8) %>%
    bind_rows() %>%
    rename_all(. %>% paste0("F",.)), by="Fprimer") %>%
    left_join(.$Rprimer %>% unique() %>% purrr::map(get_binding_position, coi_model, tryrc = TRUE, min_score=8) %>%
    bind_rows() %>%
    rename_all(. %>% paste0("R",.)), by="Rprimer")

# Read in sequences
seqs <- read.FASTA("reference/mock_spp2.fa")
names(seqs) <- names(seqs) %>% 
  str_replace("Carpophilus_nr.dimidiatus", "Carpophilus_truncatus")  %>%
  str_replace("Psyllid_sp", "Acizzia_sp")

# Add primers to seqs
primers.dna <- char2DNAbin(c("GGDACWGGWTGAACWGTWTAYCCHCC", rc("GTRATWGCHCCDGCTARWACWGG"),rc("TATDGTRATDGCHCCNGC")))
names(primers.dna) <- c("fwhF2", "fwhR2n", "HexCOIR4")

#Join to seqs
seqs <- c(seqs, primers.dna)

# Trim seqs to Fprimer bind region and get primer edit distance
aligned <- taxreturn::map_to_model(seqs, coi_model, min_score = 0, shave= TRUE, check_frame=FALSE, max_N=Inf, max_gap=Inf, kmer_threshold= 1, multithread=FALSE, quiet=FALSE, extra="fill")

#Transform to DNAstringSet
aligned <- DNAbin2DNAstringset(aligned) 
  
# Check alignment
#BrowseSeqs(aligned)

#Get forward dist
Fprimerdist <- Biostrings::subseq(aligned, start=primers$Fstart[1], end = primers$Fend[1]) %>%
  DECIPHER::DistanceMatrix(includeTerminalGaps = TRUE)%>% #hamming with ambiguities
  as.data.frame() %>%
  rownames_to_column("Fprimer") %>%
  pivot_longer(cols=-Fprimer,
               names_to="taxon",
               values_to="Fdist") %>%
  filter(Fprimer=="fwhF2", !taxon %in% names(primers.dna)) %>%
  filter(Fdist < 0.5) #Filter bad alignments

#Get reverse dist
Rprimerdist <- bind_rows(
  #Rprimer1
  Biostrings::subseq(aligned[lengths(aligned) > primers$Rend[1]],
                     start=primers$Rstart[1], end = primers$Rend[1]) %>%
  DECIPHER::DistanceMatrix(includeTerminalGaps = TRUE)%>% #hamming with ambiguities
  as.data.frame() %>%
  rownames_to_column("Rprimer") %>%
  pivot_longer(cols=-Rprimer,
               names_to="taxon",
               values_to="Rdist") %>%
  filter(Rprimer=="fwhR2n", !taxon %in% names(primers.dna)),
  #Rprimer2
Biostrings::subseq(aligned[lengths(aligned) > primers$Rend[2]],
                   start=primers$Rstart[2], end = primers$Rend[2]) %>%
  DECIPHER::DistanceMatrix(includeTerminalGaps = TRUE)%>% #hamming with ambiguities
  as.data.frame() %>%
  rownames_to_column("Rprimer") %>%
  pivot_longer(cols=-Rprimer,
               names_to="taxon",
               values_to="Rdist") %>%
  filter(Rprimer=="HexCOIR4", !taxon %in% names(primers.dna))
)%>%
  filter(Rdist < 0.5) #Filter bad alignments

# get amplicon gc content
primergc <- bind_rows(
  #primer set 1
  Biostrings::subseq(aligned[lengths(aligned) > primers$Rstart[1]],
                     start=primers$Fend[1]+1, end = primers$Rstart[1])  %>%
  letterFrequency(letters="GC", as.prob=TRUE)  %>%
  as.data.frame() %>%
  mutate(taxon = names(aligned[lengths(aligned) > primers$Rstart[1]]),
         target_subfragment = paste0(primers$Fname[1], "-", primers$Rname[1])) %>%
  dplyr::filter(!taxon %in% names(primers.dna)),
  #primer set 2
Biostrings::subseq(aligned[lengths(aligned) > primers$Rstart[2]],
                   start=primers$Fend[2]+1, end = primers$Rstart[2])  %>%
  letterFrequency(letters="GC", as.prob=TRUE)  %>%
  as.data.frame() %>%
  mutate(taxon = names(aligned[lengths(aligned) > primers$Rstart[2]]),
         target_subfragment = paste0(primers$Fname[2], "-", primers$Rname[2])) %>%
  dplyr::filter(!taxon %in% names(primers.dna))
)

joint <- joint %>%
  separate(target_subfragment, into=c("Fprimer", "Rprimer"), sep="-", remove=FALSE) %>%
  left_join(Fprimerdist) %>%
  left_join(Rprimerdist) %>%
  left_join(primergc) 

# Save moleucular traits
mol_traits <- joint %>% 
  ungroup() %>%
  dplyr::select(taxon, target_subfragment) %>% 
  distinct() %>%
  separate(target_subfragment, into=c("Fprimer", "Rprimer"), sep="-", remove=FALSE) %>%
  left_join(Fprimerdist) %>%
  left_join(Rprimerdist) %>%
  left_join(primergc)

write_csv(mol_traits, "sample_data/molecular_traits.csv")

```

## Create phylogeny

```{r phylogeny}
tree_alignment <- aligned[names(aligned) %in% joint$taxon]

phang.align <- phyDat(as(tree_alignment, "matrix"), type="DNA")

dm <- dist.ml(phang.align)

#Fit NJ tree
treeNJ <- NJ(dm) # Note, tip order != sequence order
fit <- pml(treeNJ, data=phang.align)

#Fit ML tree
fitGTR <- update(fit, k=4, inv=0.2)
fitGTR <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE,
                      rearrangement = "stochastic", control = pml.control(trace = 0))

tree <- fitGTR$tree

p1 <- ggtree(tree) + geom_tiplab()

#Output newick tree
write.tree(tree, file="output/tree.nwk")
```


## Look at differences between runs

```{r run differences}
# Plot differences in quickextract - non-quickextract between runs
gg.runra <- joint %>%
  dplyr::filter(str_detect(sample_id, "^I")) %>%
  dplyr::select(sample, taxon, observed, run, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample_id", "sample", "taxon", "run", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  mutate(run = paste0("Sequencing run ", run)) %>%
  dplyr::filter(type=="observed") %>%
    ggplot(aes(x=sample, y=value, fill=taxon)) +
    geom_col(position="stack") +
    facet_grid(run~mixture_type, scales="free") +
    scale_fill_manual(values = colours.taxon) +
    base_theme+
    theme(axis.text.x = element_text(angle=45, hjust=1),
          legend.position = "bottom") +
    scale_x_discrete(expand=c(0,0))+
    scale_y_continuous(labels = scales::percent, expand=c(0,0)) +
    labs(x="Sample", y="Relative abundance")

# Plot as heatmap
gg.runhmap <- joint %>%
  dplyr::filter(str_detect(sample_id, "^I")) %>%
  dplyr::select(sample, taxon, observed, run, mixture_type, expected, exp_individuals) %>%
  pivot_longer(-c("sample_id", "sample", "taxon", "run", "mixture_type"),
               names_to="type",
               values_to="value") %>%
  mutate(run = paste0("Sequencing run ", run)) %>%
  dplyr::filter(type=="observed") %>%
  mutate(value = na_if(value, 0),
         taxon = str_replace_all(taxon, "_", " "),
         taxon = factor(taxon, levels = rev(names(colours.taxon2)))) %>%
    ggplot(aes(x=sample, y=taxon, fill=value)) +
    geom_tile() +
    facet_grid(run~mixture_type, scales="free") +
    base_theme+
    theme(axis.text.x = element_text(angle=45, hjust=1),
          axis.text.y= element_text(face="italic"),
          legend.position = "bottom") +
    scale_x_discrete(expand=c(0,0))+
    scale_y_discrete(expand=c(0,0))+
    scale_fill_viridis_c(labels = scales::percent) +
    labs(x="Sample",
         y="Taxon",
         fill="Relative abundance")

gg.runcomparison <- gg.runra - gg.runhmap + plot_annotation(tag_levels="A")

gg.runcomparison

#Write out
pdf(file="figs/supplementary/run_comparison.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.runcomparison)
try(dev.off(), silent=TRUE)
  
# Remove the quickextract samples from run 2
joint <- joint %>%
  dplyr::filter(!(mixture_type=="QuickExtract" & run==2)) %>%
  dplyr::filter(expected > 0)
```

DNApools and PCR pools 1-4 and 5-8 arent exact replicates because of the extra species that were found

## Visualise bias

```{r visualise bias}
## Visualise errors in proportions
gg.err_prop <- joint %>% 
  mutate_at(vars(observed, expected, exp_individuals), logit) %>%
  ggplot(aes(observed, exp_individuals, color = taxon)) + 
  geom_jitter(alpha=0.7) +
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  scale_colour_manual(values = colours.taxon) +
  facet_grid(target_subfragment~mixture_type) +
  labs(x = "Observed proportions (log-odds)", 
       y= "Expected proportions (log-odds)",
       colour = "Taxon") 

gg.err_prop

#Write out
pdf(file="figs/supplementary/err_proportions.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.err_prop)
try(dev.off(), silent=TRUE)

# Visualise the error in all pairwise ratios
err_ratio <- joint %>%
  dplyr::filter(exp_individuals > 0 ) %>%
  #filter(!taxon=="Bradysia_nr.ocellaris") %>%
  dplyr::mutate(Taxon = taxon %>%
                 str_replace("^.+_", paste0(str_extract(taxon, "."), "_"))) %>%
    compute_ratios(group_vars = c("sample_id", "mixture_type", "target_subfragment")) %>%
  mutate(Pair = paste(Taxon.x, Taxon.y, sep = ":"))

# Mean error ratios
err_ratio %>% 
  group_by(mixture_type, target_subfragment) %>%
  summarise(mpr = mean(err_individuals, na.rm=TRUE))

gg.err_ratio <- err_ratio %>% 
  ggplot(aes(Pair, err_individuals, colour=sample_id)) +
  geom_jitter(alpha=0.7) +
  geom_hline(yintercept = 1) +
  scale_y_log10() +
  facet_grid(target_subfragment~mixture_type)+
    theme(legend.position = "none",
          axis.text.x = element_text(angle=45, hjust=1))+
  labs(y= "Error in taxon ratios (log10)") 

gg.err_ratio

#Save figure
pdf(file="figs/supplementary/err_ratio.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.err_ratio)
try(dev.off(), silent=TRUE)
  
# Get the average pairwise bias for each method
joint %>%
  dplyr::filter(exp_individuals > 0 ) %>%
  dplyr::mutate(Taxon = taxon %>%
                 str_replace("^.+_", paste0(str_extract(taxon, "."), "_"))) %>%
    compute_ratios(group_vars = c("sample_id", "mixture_type", "target_subfragment")) %>%
  group_by(mixture_type, target_subfragment) %>%
  summarise(mean = mean(err_individuals, na.rm=TRUE), sd = sd(err_individuals, na.rm=TRUE), lower = range(err_individuals, na.rm = TRUE)[1], upper = range(err_individuals, na.rm = TRUE)[2])
```


# Compare bias models

We will now estimate the bias using different conventional and CODA models

## Create test and training splits

```{r training test split}
# Make training / testing splits  ------------------------------------------------------------
set.seed(666)

joint_split <- joint  %>%
  ungroup() %>%
  dplyr::select(sample_id, mixture_type) %>%
  distinct() %>%
  initial_split(strata = mixture_type, prop = .8)
  
# Training set
joint_train <- joint %>%
  filter(sample_id %in% training(joint_split)$sample_id)
  
# Testing set
joint_test <- joint %>%
  filter(sample_id %in% testing(joint_split)$sample_id) 

# Check for data leakage
table(unique(joint_train$sample_id) %in% unique(joint_test$sample_id))
table(unique(joint_test$sample_id) %in% unique(joint_train$sample_id))

# Create Cross validation folds for model tuning 
train_cv <- joint_train %>%
  group_vfold_cv(v = 5, group = sample_id) #Ensures samples are kept together

# Create full modelling data object
model_df <- tibble(
  full_data = list(joint),
  train = list(joint_train),
  test = list(joint_test),
  cv = list(train_cv))

```

## Mean proportions

Here we estimate bias as the arithmetic mean of the error in proportions

```{r mean proportions}
# Learn correction factors from training set
fit_prop <- model_df %>%
  mutate(
    model_obj = purrr::map(train, function(x){
      x %>%
        mutate(error = observed / exp_individuals) %>%
        group_by(mixture_type, target_subfragment, taxon) %>%
        summarise(.pred = mean(error))
  }),
  pred_train = purrr::map2(train, model_obj, function(x,y){
    x %>%
        left_join(y) %>%
        mutate(
        predicted = exp_individuals * .pred, 
        observed = observed,
        estimated = .pred
      )%>%
    group_by(sample_id) %>%
    mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) 
    
  }),
  pred_test = purrr::map2(test, model_obj, function(x,y){
    x %>%
        left_join(y) %>%
        mutate(
        predicted = exp_individuals * .pred, 
        observed = observed,
        estimated = .pred
      )%>%
    group_by(sample_id) %>%
    mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) 
  })
  )
  
# See results on training set
fit_prop %>%
  unnest(pred_train)%>%
    dplyr::select(!where(is.list)) %>%
  group_by(mixture_type, target_subfragment) %>%
  rmse(truth = observed, estimate = predicted)

# See results on test_set
fit_prop %>%
  unnest(pred_test)%>%
    dplyr::select(!where(is.list)) %>%
  group_by(mixture_type, target_subfragment) %>%
  rmse(truth = observed, estimate = predicted)
```

## simple lm

Here we estimate bias using a simple linear regression model of the expected and observerd proportions. The model is fit seperately to each taxon and material type.

```{r simple lm}
# Specify LM
lm_spec <- linear_reg() %>%
  set_engine(engine = "lm")
lm_spec

# Learn correction factors from training set
fit_lm <- model_df %>%
  mutate(
    model_obj = purrr::map(train, function(x){
      x  %>%
        group_by(taxon, target_subfragment, mixture_type) %>%
        nest() %>%
        mutate(lm_obj = map(data, ~fit(lm_spec, observed ~ 0 + exp_individuals, data = .)),
               coef_info = map(lm_obj, tidy)) %>%
        unnest(coef_info)
  }),
  pred_train = purrr::map2(train, model_obj, function(x,y){
      x %>% 
        left_join(y) %>% 
        mutate(
          predicted = exp_individuals * estimate, 
          observed = observed,
          estimated = estimate
        )%>%
        group_by(sample_id) %>%
        mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) 
  }),
  pred_test = purrr::map2(test, model_obj, function(x,y){
      x %>% 
        left_join(y) %>% 
        mutate(
          predicted = exp_individuals * estimate, 
          observed = observed,
          estimated = estimate
        )%>%
        group_by(sample_id) %>%
        mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) 
  }))

# See results on training set
fit_lm %>%
  unnest(pred_train)%>%
    dplyr::select(!where(is.list)) %>%
  group_by(mixture_type, target_subfragment) %>%
  rmse(truth = observed, estimate = predicted)

# See results on test_set
fit_lm %>%
  unnest(pred_test)%>%
    dplyr::select(!where(is.list)) %>%
  group_by(mixture_type, target_subfragment) %>%
  rmse(truth = observed, estimate = predicted)

```

## Complm

Estimating bias  is complicated by the compositional nature of metabarcoding measurements. Because only relative abundances are measured, the measurement of a  sample (s) only provides information about the efficiencies of the taxa in the sample relative to each other.

Here we fit a simple linear model on the compositional difference between Observed and Expected counts. The compositional error vectors are first geometrically centered, then taxon is used as a predictor.

NOTE: Fitting a split sample regression as below (grouped by mixture type) is analogous to fitting a fully interaction regression (i.e. taxon * mixture_type)


```{R compositional regressions}
# Specify complm spec
complm_spec <- linear_reg() %>%
  set_engine(engine = "lm")
complm_spec

# Learn correction factors from training set
fit_complm <- model_df %>%
  mutate(
    model_obj = purrr::map(train, function(x){
      x  %>%
        group_by(target_subfragment, mixture_type) %>%
        nest() %>%
        mutate(lm_obj = map(data, ~fit(complm_spec, err_individuals ~ 0 + taxon, data = .)),
               coef_info = map(lm_obj, tidy)) %>%
        dplyr::select(-data)
  }),
  pred_train = purrr::map2(train, model_obj, function(x,y){
      x %>%
        group_by(target_subfragment, mixture_type) %>%
        nest() %>%
        left_join(y)  %>%
        mutate(pred = map2(lm_obj, data, function(.model, .data) predict(.model, .data))) %>%
        unnest(data, pred)%>% 
        mutate(
          predicted = exp_individuals * exp(.pred), 
          estimated = exp(.pred)
        ) %>%
        group_by(sample_id) %>%
        mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) %>%
        ungroup() %>%
        dplyr::select(!where(is.list))
  }),
  pred_test = purrr::map2(test, model_obj, function(x,y){
      x %>%
        group_by(target_subfragment, mixture_type) %>%
        nest() %>%
        left_join(y)  %>%
        mutate(pred = map2(lm_obj, data, function(.model, .data) predict(.model, .data))) %>%
        unnest(data, pred)%>% 
        mutate(
          predicted = exp_individuals * exp(.pred), 
          estimated = exp(.pred)
        ) %>%
        group_by(sample_id) %>%
        mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) %>%
        ungroup() %>%
        dplyr::select(!where(is.list))
  }))


# See results on training set
fit_complm %>%
  unnest(pred_train)%>%
    dplyr::select(!where(is.list)) %>%
  group_by(mixture_type, target_subfragment) %>%
  rmse(truth = observed, estimate = predicted)

# See results on test_set
fit_complm %>%
  unnest(pred_test)%>%
    dplyr::select(!where(is.list)) %>%
  group_by(mixture_type, target_subfragment) %>%
  rmse(truth = observed, estimate = predicted)

```

## metacal

Here we use the bias estimation approach of *McLaren, M. R., Willis, A. D., & Callahan, B. J. (2019). Consistent and correctable bias in metagenomic sequencing experiments. Elife, 8.* This approach treats the abundances and errors as compositional vectors and estimates the bias as the geometric center of these bias vectors. 

This is a compositionally appropriate alternative to taking the arithmetic mean of errors in proportions as above.

```{R metacal}

# Learn correction factors from training set
fit_metacal <- model_df %>%
  mutate(
    model_obj = purrr::map(train, function(x){
      x %>%
        group_by(target_subfragment, mixture_type) %>%
        nest() %>%
        mutate(
            fit = purrr::map(data, function(x){
            obs_mat <- x %>%
              dplyr::select(sample_id, taxon, observed)%>%
              pivot_wider(id_cols= sample_id,
                          names_from = "taxon",
                          values_from = "observed",
                          values_fill = list(observed=0))%>%    
              column_to_rownames("sample_id") %>%
              as.matrix() 
            
            exp_mat <- x %>%
              dplyr::select(sample_id, taxon, expected)%>%
              pivot_wider(id_cols= sample_id,
                          names_from = "taxon",
                          values_from = "expected",
                          values_fill = list(expected=0))%>%    
              column_to_rownames("sample_id") %>%
              as.matrix() 
                    
           trained_mc <- estimate_bias(
              obs_mat,
              exp_mat, 
              margin = 1, # samples as rows
              boot = TRUE
            ) %>%
             summary()
           out <- trained_mc$coefficients %>%
             dplyr::rename(.pred = estimate)
           return(out)
            })) %>%
        unnest(fit) 
  }),
  pred_train = purrr::map2(train, model_obj, function(x,y){
      x %>%
        left_join(y) %>%
        mutate(
          predicted = exp_individuals * .pred,
          estimated = .pred
        ) %>%
        group_by(sample_id) %>%
        mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) %>%
        ungroup() %>%
        dplyr::select(!where(is.list))
  }),
  pred_test = purrr::map2(test, model_obj, function(x,y){
      x %>%
        left_join(y) %>%
        mutate(
          predicted = exp_individuals * .pred,
          estimated = .pred
        )%>%
        group_by(sample_id) %>%
        mutate_at(vars(predicted), ~ . / sum(., na.rm=TRUE) ) %>%
        ungroup() %>%
        dplyr::select(!where(is.list))
  }))

# See results on training set
fit_metacal %>%
  unnest(pred_train)%>%
    dplyr::select(!where(is.list)) %>%
  group_by(mixture_type, target_subfragment) %>%
  rmse(truth = observed, estimate = predicted)

# See results on test_set
fit_metacal %>%
  unnest(pred_test)%>%
    dplyr::select(!where(is.list)) %>%
  group_by(mixture_type, target_subfragment) %>%
  rmse(truth = observed, estimate = predicted)

```


# Evaluate model fits

Here we compare the accuracy of the bias estimation procedure by looking at the Root Mean Square Error (RMSE) between the observed relative abundances from sequencing, and the predicted relative abundances (Expected * Bias estimate) from each model.

To determine the models predictive ability to new data, we also determine these metrics for a seperate testing set of samples that the model was not trained on.

```{R model comparison}
all_fits <- do.call("list", mget(grep("fit_",names(.GlobalEnv),value=TRUE))) %>%
  bind_rows(.id="model")
  #filter(!model == "boot_results")

# Get all fits for training dataset
all_train <- all_fits %>%
  mutate(
    model = model %>%
    str_remove("fit_"))  %>%
  unnest(pred_train)%>%
  dplyr::select(!where(is.list)) %>%
  dplyr::select(model, taxon, mixture_type, target_subfragment, sample_id,
                run, exp_individuals, observed, predicted, estimated) 

# Plot bias estimates
gg.ests_train <- all_train %>%
  ggplot(aes(taxon, y=estimated-1, fill=model, group=model)) +
    geom_col(position=position_dodge(width=0.9))+
    facet_grid(target_subfragment~mixture_type, scales="free") +
  coord_flip() +
  scale_fill_brewer(palette="Paired") +
  labs(
    x = "Taxon",
    y = "Bias estimate",
    fill="Model",
    title = "Training set")

all_test <- all_fits %>%
  mutate(
    model = model %>%
    str_remove("fit_"))  %>%
  unnest(pred_test)%>%
  dplyr::select(!where(is.list)) %>%
  dplyr::select(model, taxon, mixture_type, target_subfragment, sample_id,
                run, exp_individuals, observed, predicted, estimated) 

gg.ests_test <- all_test %>%
  ggplot(aes(taxon, y=estimated-1, fill=model, group=model)) +
    geom_col(position=position_dodge(width=0.9))+
    facet_grid(target_subfragment~mixture_type, scales="free") +
  coord_flip() +
  scale_fill_brewer(palette="Paired") +
  labs(
    x = "Taxon",
    y = "Bias estimate",
    fill="Model",
    title = "Test set")

#Save figure
pdf(file="figs/model_comparisons/bias_estimates.pdf", width = 8, height = 11 , paper="a4")
  plot(gg.ests_train)
  plot(gg.ests_test)
try(dev.off(), silent=TRUE)
```

## How well do the bias models explain the data?

```{r model fits}
# Visualise fits to training set
gg.preds_train <- all_train %>%
  ggplot(aes(predicted, observed, color = taxon, shape=target_subfragment)) +
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  geom_rangeframe(colour="black")+
  geom_point(alpha = 0.5) +
  coord_fixed() + 
  facet_grid(mixture_type~model) +
  scale_colour_manual(values = colours.taxon) +
  base_theme +
  theme(panel.grid = element_line(size = rel(1))) +
  scale_y_continuous(trans=pseudo_log_trans(0.01), labels=scales::percent_format(accuracy=1), 
                     breaks=c(0, 0.02, 0.05, 0.1, 0.2, 0.5, 1), limits=c(0,1), expand = c(0,0))+
  scale_x_continuous(trans=pseudo_log_trans(0.01), labels=scales::percent_format(accuracy=1), 
                     breaks=c(0, 0.02, 0.05, 0.1, 0.2, 0.5, 1), limits=c(0,1), expand = c(0,0))+
  scale_alpha_continuous(range=c(0.3, 0.9))+
  theme(panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = "none",
        legend.text = element_text(face="italic")) +
    labs(x = "Bias model prediction", 
        y = "Observed proportions",
        fill = "Taxon", 
        title = "Training set",
        colour= NULL) 

gg.preds_train

# Visualize fits to test set
gg.preds_test <- all_test %>%
  ggplot(aes(predicted, observed, color = taxon, shape=target_subfragment)) +
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  geom_rangeframe(colour="black")+
  geom_point(alpha = 0.5) +
  coord_fixed() + 
  facet_grid(mixture_type~model) +
  scale_colour_manual(values = colours.taxon) +
  base_theme +
  theme(panel.grid = element_line(size = rel(1))) +
  scale_y_continuous(trans=pseudo_log_trans(0.01), labels=scales::percent_format(accuracy=1), 
                     breaks=c(0, 0.02, 0.05, 0.1, 0.2, 0.5, 1), limits=c(0,1), expand = c(0,0))+
  scale_x_continuous(trans=pseudo_log_trans(0.01), labels=scales::percent_format(accuracy=1), 
                     breaks=c(0, 0.02, 0.05, 0.1, 0.2, 0.5, 1), limits=c(0,1), expand = c(0,0))+
  scale_alpha_continuous(range=c(0.3, 0.9))+
  theme(panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = "none",
        legend.text = element_text(face="italic")) +
    labs(x = "Bias model prediction", 
        y = "Observed proportions",
        fill = "Taxon", 
        title = "Test set",
        colour= NULL) 

gg.preds_test

#Save figure
pdf(file="figs/model_comparisons/bias_preds.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.preds_train)
  plot(gg.preds_test)
try(dev.off(), silent=TRUE)

# plot rmse
gg.rmse_train <-  all_train %>%
  group_by(model, target_subfragment, mixture_type) %>%
  rmse(truth = observed, estimate = predicted) %>%
  filter(!model %in% c("fra", "fra2")) %>%
  ggplot(aes(x=model, y=.estimate, fill=model)) +
  geom_col() +
  facet_grid(target_subfragment~mixture_type) +
  scale_fill_brewer(palette="Paired") +
  theme(axis.text.x = element_text(angle=45, hjust = 1)) +
  labs(x = "Model",
       y = "RMSE",
       title = "Training set")+
  theme(axis.text.x = element_text(angle=45, hjust = 1))

# plot rmse
gg.rmse_test <-  all_test %>%
  group_by(model, target_subfragment, mixture_type) %>%
  rmse(truth = observed, estimate = predicted) %>%
  filter(!model %in% c("fra", "fra2")) %>%
  ggplot(aes(x=model, y=.estimate, fill=model)) +
  geom_col() +
  facet_grid(target_subfragment~mixture_type) +
  scale_fill_brewer(palette="Paired") +
  theme(axis.text.x = element_text(angle=45, hjust = 1)) +
  labs(x = "Model",
       y = "RMSE",
       title = "Test set")+
  theme(axis.text.x = element_text(angle=45, hjust = 1))

#Save figure
pdf(file="figs/model_comparisons/rmse.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.rmse_train)
  plot(gg.rmse_test)
try(dev.off(), silent=TRUE)
```

## How well do the estimated bias recover the true composition

```{r calibration}
gg.cal_train <- all_train %>%
    ungroup() %>%
    dplyr::mutate(calibrated = observed / estimated) %>%
    group_by(sample_id, model) %>%
    mutate_at(vars(calibrated), ~ . / sum(., na.rm=TRUE) )  %>%
    ungroup() %>%
    ggplot(aes(x=taxon, y= odds(calibrated) / odds(exp_individuals), shape=target_subfragment )) +
    geom_hline(yintercept=1, alpha=0.8)+
    geom_jitter(aes(x=taxon, y= odds(observed) / odds(exp_individuals)),
              colour="grey", alpha=0.7, width = 0.1, height = 0)+
    geom_jitter(aes(colour = taxon),alpha=0.7, width = 0.1, height = 0) +
    geom_rangeframe(color = "black") + 
    scale_y_log10() + 
    facet_grid(mixture_type ~ model) +
    labs(x = "Taxon", 
        y = "Odds calbirated / expected",
        colour = "Taxon",
        shape = "Primer pair",
        title = "Training set") +
    coord_flip() +
    scale_color_manual(values = colours.taxon) + 
    theme(legend.position = "bottom")

gg.cal_train

gg.cal_test <- all_train %>%
    ungroup() %>%
    dplyr::mutate(calibrated = observed / estimated) %>%
    group_by(sample_id, model) %>%
    mutate_at(vars(calibrated), ~ . / sum(., na.rm=TRUE) )  %>%
    ungroup() %>%
    ggplot(aes(x=taxon, y= odds(calibrated) / odds(exp_individuals), shape=target_subfragment )) +
    geom_hline(yintercept=1, alpha=0.8)+
    geom_jitter(aes(x=taxon, y= odds(observed) / odds(exp_individuals)),
              colour="grey", alpha=0.7, width = 0.1, height = 0)+
    geom_jitter(aes(colour = taxon),alpha=0.7, width = 0.1, height = 0) +
    geom_rangeframe(color = "black") + 
    scale_y_log10() + 
    facet_grid(mixture_type ~ model) +
    labs(x = "Taxon", 
        y = "Odds calbirated / expected",
        colour = "Taxon",
        shape = "Primer pair",
        title = "Training set") +
    coord_flip() +
    scale_color_manual(values = colours.taxon) + 
    theme(legend.position = "bottom")

gg.cal_test


#Save figure
pdf(file="figs/model_comparisons/calibration.pdf", width = 11, height = 8 , paper="a4r")
  plot(gg.cal_train)
  plot(gg.cal_test)
try(dev.off(), silent=TRUE)

```

From the above we can see that the complm model fits the data the best. We will do the rest of the analysis using this model.

# Fit final model 

We will use bootstrapping to get a best estimate and associated confidence intervals, which will take the form of geometric mean and standard deviations of the bootstrap estimates.

Tje geometric mean and the geometric standard deviation of a sample of data from a log-normally distributed population may be used to find the bounds of confidence intervals analogously to the way the arithmetic mean and standard deviation are used to bound confidence intervals for a normal distribution.

When using geometric SD factor in conjunction with geometric mean, it should be described as "the range from (the geometric mean divided by the geometric SD factor) to (the geometric mean multiplied by the geometric SD factor), and one cannot add/subtract "geometric SD factor" to/from geometric mean

Therefore the estimated efficiencies are shown as the best estimate multiplied and divided by two geometric standard errors

```{r Final model}
lm_dat <- model_df %>%
  unnest(full_data)%>%
  dplyr::select(!where(is.list)) %>%
  group_by(mixture_type, target_subfragment) 

group_name <- group_keys(lm_dat) %>%
  unite(col="name", everything(), sep=";") %>%
  pull(name)

lm_dat <- lm_dat %>%
  group_split() %>%
  set_names(group_name)

set.seed(606)
boots <- purrr::map(lm_dat, bootstraps, times=1000, apparant=TRUE)

# Fit model to bootstraps
boot_models <- boots %>% 
  purrr::map(function(x){ 
    x %>%
      mutate(
        #  lm_obj = map(data, ~fit(lm_spec, err_individuals ~ 0 + taxon, data = .x)),
        lm_obj = map(splits, ~lm(err_individuals ~ 0 + taxon, data = .)), #why cant i use lm spec here?
            pred = map2(lm_obj, splits, function(.model, .data) predict(.model, .data)),
            coef_info = map(lm_obj, tidy),
            aug = map(lm_obj, broom::augment),
            data = map(splits, function(y){
              as.data.frame(y) %>%
                dplyr::select(observed, count, mixture_type, sample_id, taxon, exp_individuals)})
        ) 
    }) 

#check the distribution of the bootstrapped residuals to see whether they are normally distributed
boot_res <- boot_models %>% 
  purrr::map(function(x){ 
    x <- x %>%
      unnest(aug)
  })  %>%
  bind_rows(.id="name") %>%
  tidyr::separate(name, into=c("mixture_type", "target_subfragment"), sep=";") %>%
  mutate(extract_type = case_when(
      mixture_type=="DNEasy" ~ "DNEasy",
      mixture_type=="QuickExtract" ~ "QuickExtract",
      TRUE ~ "NA"
    ))%>%
    dplyr::select(!where(is.list))%>%
  ungroup()

# QQplot of residuals
boot_res %>%
  dplyr::slice_sample(n=100000) %>%
  ggplot(aes(sample = .resid, group=taxon, colour=taxon)) +
  stat_qq() + 
  stat_qq_line(colour="black") +
  facet_grid(taxon~target_subfragment)+
  base_theme +
  scale_colour_manual(values=colours.taxon)+
  theme(legend.position = "none")

# Density plot of residuals
boot_res %>%
  dplyr::slice_sample(n=100000) %>%
  ggplot(aes(x = .resid, group=taxon, colour=taxon)) +
  geom_density() +
  facet_grid(taxon~target_subfragment)+
  base_theme +
  scale_colour_manual(values=colours.taxon)+
  theme(legend.position = "none")

# Shapiro wilks test
shap_test <- boot_res %>%
  group_by(taxon, target_subfragment) %>%
  dplyr::slice_sample(n=5000) %>%
  summarise(test = broom::tidy(shapiro.test(.resid)))

# Get coefficients
boot_coefs <- boot_models %>% 
  purrr::map(function(x){ 
    x <- x %>%
      unnest(coef_info)
  }) %>%
  bind_rows(.id="name") %>%
  tidyr::separate(name, into=c("mixture_type", "target_subfragment"), sep=";") %>%
  mutate(taxon = str_remove(term, "taxon")) %>%
  mutate(extract_type = case_when(
      mixture_type=="DNEasy" ~ "DNEasy",
      mixture_type=="QuickExtract" ~ "QuickExtract",
      TRUE ~ "NA"
    ))%>%
    dplyr::select(!where(is.list))%>%
  ungroup() %>%
  mutate(log_est = estimate) %>%
  mutate(estimate = exp(estimate))

# Plot uncertainty in bootstrapped coefficients
boot_coefs %>%
  filter(term != "(Intercept)") %>% 
  ggplot(aes(x = taxon, y = log_est, fill=taxon)) +  
  geom_hline(yintercept = 0, lty = 3) + 
  #geom_line(alpha = 0.3, lwd = 1.2) + 
  geom_violin()+
  labs(y = "Coefficient", x = NULL) +
  base_theme +
  scale_fill_manual(values=colours.taxon)+
  theme(legend.position = "none")


## Visualise errors in unmodelled proportions
prop_rmse <- joint %>%
  mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  group_by(target_subfragment, mixture_type) %>%
  rmse(truth = expected, estimate = observed) #could also do somethign  else here

gg.err_prop <- joint %>%
  mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>% 
  #mutate_at(vars(observed, expected, exp_individuals), logit) %>%
  ggplot(aes(exp_individuals,observed, color = taxon)) + 
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  geom_point(alpha=0.5) +
    geom_text(data=prop_rmse, aes(x=0.2, y=0.85, label=paste0("RMSE: ",scales::percent(.estimate, accuracy = 1))),check_overlap = TRUE, inherit.aes = FALSE, hjust = 1)+
  scale_colour_manual(values = colours.taxon) +
  scale_y_continuous(trans=pseudo_log_trans(0.01), labels=scales::percent_format(accuracy=1), breaks=c(0, 0.02, 0.05, 0.1, 0.25, 0.5, 1))+
  scale_x_continuous(trans=pseudo_log_trans(0.01), labels=scales::percent_format(accuracy=1), breaks=c(0, 0.02, 0.05, 0.1, 0.25, 0.5, 1))+
  facet_grid(target_subfragment~mixture_type) +
  labs(x = "Expected proportions", 
       y = "Observed proportions",
       colour = "Taxon")  +
  base_theme +
  theme(panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = "none",
        legend.text = element_text(face="italic")) +
    facet_grid(target_subfragment~mixture_type) +
  coord_cartesian(xlim = c(0,1), ylim = c(0, 1))

gg.err_prop


# Could i make this a distribution of the bootstrap estimates, either a confidence range or violin plot

gg.final_ests <- boot_coefs  %>%
    group_by(taxon, target_subfragment, mixture_type) %>%
    summarise(gm_quantiles(estimate, q = c(0.025, 0.25, 0.75, 0.975), na_rm=TRUE, wide=TRUE),
              gm_mean = metacal::gm_mean(estimate, na.rm=TRUE),
              gm_se = metacal::gm_sd(estimate, na.rm = TRUE)) %>%
    ungroup %>%
    rename_with(~gsub("^q", "gm_", .x), starts_with("q")) %>%
    mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  mutate(taxon = taxon %>% 
           str_replace("_", " ") %>%
           factor(levels = rev(names(colours.taxon2)))) %>%
  ggplot(aes(x=gm_mean , y=taxon, colour=taxon, fill=taxon))+ #
  geom_vline(xintercept = 1, colour="grey80" )  +
  geom_interval(aes(xmin = gm_025, xmax =gm_975 ), alpha=0.5, size=3) +
  geom_interval(aes(xmin = gm_25, xmax = gm_75 ), alpha=0.8, size=3) +
  geom_point(colour="black", shape=21)+
  scale_colour_manual(values = colours.taxon2) +
  scale_fill_manual(values = colours.taxon2) +
  scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x))) +
  annotation_logticks(sides="b", outside=TRUE) +
  base_theme +
  theme(#panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_blank(),
        legend.position = "none",
        axis.text.x = element_text(angle=0, hjust = 0.5, vjust = 1),
        axis.text.y = element_text(face = "italic"),
        legend.text = element_text(face="italic")) +
    facet_grid(target_subfragment~mixture_type) +
  labs(y = NULL, 
       x = "Efficiency / geometric mean",
      colour = "Taxon",
      level = "Confidence interval")+
  guides(fill=FALSE) +
  coord_cartesian(clip = "off")

gg.final_ests


Fig1 <- gg.err_prop /  gg.final_ests  + plot_layout(heights = c(1,2)) + plot_annotation(tag_levels = "A")  & theme(plot.margin =unit(c(0,0,0,0), "cm"))

#Fig1

#Save figure
pdf(file="figs/fig1_bias.pdf", width = 8, height = 8 , paper="a4")
  plot(Fig1)
try(dev.off(), silent=TRUE)
  
# SUpplementary figure 2 - fit of bootstrapped bias model
boot_results <- boot_models%>% 
  purrr::map(function(x){ 
    x <- x %>%
      unnest(pred, data)
  }) %>%
  bind_rows(.id="name") %>%
  tidyr::separate(name, into=c("mixture_type", "target_subfragment"), sep=";") %>%
  dplyr::filter(exp_individuals > 0)%>% 
  mutate(
    predicted = exp_individuals * exp(pred), 
    estimated = exp(pred)
  ) %>%
  group_by(sample_id, id) %>%
  mutate_at(vars(predicted, observed, exp_individuals), ~ . / sum(., na.rm=TRUE) ) %>% #re-close elements
  dplyr::select(!where(is.list))

# Get RMSE
final_rmse <- boot_results %>%
  mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  group_by(target_subfragment, mixture_type) %>%
  rmse(truth = observed, estimate = predicted) #could also do somethign  else here

# Visualise fits to data
gg.final_fits <- boot_results %>%
  mutate(mixture_type = factor(mixture_type, levels=c("QuickExtract", "DNEasy", "DNA", "PCR"))) %>%
  ggplot(aes(x = predicted, y = observed)) +
  geom_abline(lty = 2, colour = "gray80", size = 1) +
  stat_density_2d(geom = "polygon", aes(alpha = ..level.., fill = taxon))+
  facet_grid(target_subfragment~mixture_type) +
  scale_fill_manual(values = colours.taxon) +
  scale_colour_manual(values = colours.taxon) +
  base_theme +
  theme(panel.grid = element_line(size = rel(1))) +
  scale_y_continuous(trans=pseudo_log_trans(0.01), labels=scales::percent_format(accuracy=1), 
                     breaks=c(0, 0.02, 0.05, 0.1, 0.25, 0.5, 1), limits=c(0,1), expand = c(0,0))+
  scale_x_continuous(trans=pseudo_log_trans(0.01), labels=scales::percent_format(accuracy=1), 
                     breaks=c(0, 0.02, 0.05, 0.1, 0.25, 0.5, 1), limits=c(0,1), expand = c(0,0))+
  scale_alpha_continuous(range=c(0.3, 0.9))+
  theme(panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        legend.position = "none",
        legend.text = element_text(face="italic")) +
    labs(x = "Bias model prediction", 
        y = "Observed proportions",
        fill = "Taxon", 
        colour= NULL)   
  
  
#Save supplementary figure
pdf(file="figs/supplementary/bootstrap_fits.pdf", width = 8, height = 9 , paper="a4")
  plot(gg.final_fits)
try(dev.off(), silent=TRUE)
  
# SUppleemntary table 1 - Overall model fits
# Function to make p values
lmp <- function (modelobject) {
    if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
    f <- summary(modelobject)$fstatistic
    p <- pf(f[1],f[2],f[3],lower.tail=F)
    attributes(p) <- NULL
    return(p)
}

# Bootstrap estimates of model statistics
boot_models_stats <- boot_models %>% 
  bind_rows(.id="name") %>%
  dplyr::select(name, id, lm_obj) %>%
  tidyr::separate(name, into=c("mixture_type", "target_subfragment"), sep=";") %>%
  mutate(model_stats = purrr::map(lm_obj, function(x){
    fit <- summary(x)
    tibble(
      f_stat = fit$fstatistic[1],
      numdf = fit$fstatistic[2],
      demdf = fit$fstatistic[3],
      rsq =fit$r.squared,
      adj_rsq = fit$adj.r.squared,
      p_val = lmp(x)
    )
    }))%>%
  unnest_wider(model_stats) %>%
  drop_na() %>%
  group_by(mixture_type, target_subfragment) %>% 
  dplyr::do(rsq = rsample:::pctl_single(.$rsq, alpha = 0.05),
            adj_rsq = rsample:::pctl_single(.$adj_rsq, alpha = 0.05),
            f_stat = rsample:::pctl_single(.$f_stat, alpha = 0.05),
            p_val = rsample:::pctl_single(.$p_val, alpha = 0.05)
            )  %>%
  unnest(rsq, adj_rsq, f_stat, p_val, names_sep = "")  %>%
  mutate(signif = case_when(
    between(p_val.estimate, 0, 0.001) ~ "***",
    between(p_val.estimate, 0.001, 0.01) ~ "**",
    between(p_val.estimate, 0.01, 0.05) ~ "**",
    TRUE ~ "ns")
    ) %>%
  left_join(final_rmse) %>%
  dplyr::select(-contains("method"), -contains("alpha"))  %>%
  dplyr::select(pcr_primers = target_subfragment, community_type = mixture_type, r2 = rsq.estimate, adj_r2 = adj_rsq.estimate, rmse = .estimate, fstat = f_stat.estimate , pval = p_val.estimate, signif)

boot_models_stats %>%
  write_csv("output/results/TableS1_model_fits.csv")


# Suplementary table 2, taxon coefficients
taxon_coef <- boot_coefs  %>%
    group_by(taxon, target_subfragment, mixture_type) %>%
    summarise(gm_quantiles(estimate, q = c(0.025, 0.25, 0.75, 0.975), na_rm=TRUE, wide=TRUE),
              gm_mean = metacal::gm_mean(estimate, na.rm=TRUE),
              gm_se = metacal::gm_sd(estimate, na.rm = TRUE))  %>%
  #mutate(gm_mean= log10(gm_mean), gm_se = log10(gm_se)) %>%
  dplyr::select(taxon, pcr_primers = target_subfragment, community_type = mixture_type, relative_efficiency = gm_mean, se = gm_se)

taxon_coef %>%
  write_csv("output/results/TableS2_bias_estimates.csv")
```


# Bias partitioning

```{r Bias partition}
# Partition the bias in all bootstrap replicates
boot_partitioned <- boot_coefs %>%
  dplyr::filter(!extract_type=="NA") %>% 
  dplyr::select(target_subfragment,  extract_type, mixture_type,
                taxon, id, estimate, id) %>%
  left_join(boot_coefs %>%
  dplyr::filter(extract_type=="NA") %>%
  dplyr::select(taxon, target_subfragment, mixture_type,id, estimate) %>%
    distinct %>%
    pivot_wider(names_from = mixture_type,
              values_from=estimate)) %>%
  group_by(extract_type, target_subfragment, taxon, id) %>%
    transmute(bias_all = estimate,
              bias_extract = estimate / DNA,
              bias_PCR = DNA / PCR,
              bias_seq = PCR)

# Calculate bias as geometric mean, and standard error as geometric standard error of bootstrap replicates
bias_steps <- boot_partitioned %>%
  pivot_longer(starts_with("bias_"),
               names_to = c(".value", "step"),
               names_sep="_") %>%
    group_by(taxon, target_subfragment,extract_type, step) %>%
    summarise(gm_quantiles(bias, q = c(0.025, 0.25, 0.75, 0.975), na_rm=TRUE, wide=TRUE),
              gm_mean = metacal::gm_mean(bias, na.rm=TRUE),
              gm_se = metacal::gm_sd(bias, na.rm = TRUE)) %>%
    ungroup %>%
    rename_with(~gsub("^q", "gm_", .x), starts_with("q"))

# Suplementary table 3, partitioned bias coefficients
bias_steps %>%
  dplyr::select(taxon, pcr_primers = target_subfragment, workflow_step = step, workflow_type = extract_type, bias = gm_mean, se = gm_se) %>%
  pivot_wider(names_from = workflow_step,
              values_from = c("bias", "se")) %>%
  dplyr::select(taxon, pcr_primers, workflow_type, bias_all, se_all, bias_extract, se_extract, bias_PCR, se_PCR, bias_postpcr = bias_seq, se_postpcr = se_seq) %>%
  write_csv("output/results/TableS3_bias_partitioned.csv")

gg.bias_steps <- bias_steps %>%
  dplyr::filter(!(extract_type=="QuickExtract" & !step=="extract")) %>%
  ungroup() %>%
    mutate(extract_type = case_when(
      !step=="extract" ~ "NA",
      TRUE ~ extract_type
      )) %>%
  dplyr::filter(!step=="all") %>%
  dplyr::mutate(step = step %>% 
                  str_replace("extract", "DNA Extraction") %>%
                  str_replace("seq", "Post-PCR")) %>%
    mutate(taxon = taxon %>% 
           str_replace("_", " ") %>%
           factor(levels = rev(names(colours.taxon2)))) %>%
  ggplot(aes(x=gm_mean,y=taxon, shape=extract_type, colour = taxon, fill = taxon)) +
  geom_vline(xintercept = 1, colour="grey80" )  +
  geom_interval(aes(xmin = gm_025, xmax =gm_975 ), size=2,
      position = position_dodgev(height = 0.8), alpha=0.5) +
  geom_interval(aes(xmin = gm_25, xmax = gm_75 ), size=2,
      position = position_dodgev(height = 0.8), alpha=0.8) +
  geom_point(position = position_dodgev(height = 1), colour="black")+
  scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
              labels = trans_format("log10", math_format(10^.x))) +
  annotation_logticks(sides="b", outside=TRUE) +
  scale_colour_manual(values = colours.taxon2) +
  scale_fill_manual(values = colours.taxon2) +
  scale_shape_manual(values = c(23,21,24))+ 
  facet_grid(target_subfragment~step)+
  base_theme+
  theme(#panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.text.y = element_text(face ="italic"),
        axis.text.x = element_text(angle=0, hjust=0.5),
        legend.position = "none") +
      labs(x = "Contribution of laboratory step",
         y = "Efficiency / geometric mean",
         colour = "Taxon",
         shape = "DNA Extraction") +
  coord_cartesian(clip = "off")


gg.bias_steps

# Relative abundance trajectories through the workflow
ra_traj <- bias_steps %>%
    pivot_wider(names_from = step,
              values_from=starts_with("gm_")) %>%
  group_by(extract_type, target_subfragment) %>%
  transmute(taxon,
        RA_Insects = 1,
        SE_Insects = 1,
        RA_DNA = RA_Insects * gm_mean_extract, 
        SE_DNA = SE_Insects * gm_se_extract,
        RA_Amplicons = RA_DNA * gm_mean_PCR, 
        SE_Amplicons = SE_DNA * gm_se_PCR,
        RA_Libraries = RA_Amplicons * gm_mean_seq,
        SE_Libraries = SE_Amplicons * gm_se_seq
        ) %>%
  mutate(taxon = fct_reorder(taxon, RA_Libraries)) %>%
  pivot_longer(starts_with(c("RA_", "SE_")),
               names_to = c(".value", "position"),
               values_to = "abundance",
               names_pattern = "(..)(_.*$)"
               ) %>%
  mutate(position = position %>% str_remove("_") %>%
           factor(levels=c("Insects", "DNA", "Amplicons", "Libraries")))


## Plot the trajectories as small multiples with error pars
    
gg.ra_traj <- ra_traj %>%
  dplyr::filter(extract_type == "DNEasy") %>%
  mutate(taxon = taxon %>% 
       str_replace("_", " ") %>%
       factor(levels =  names(colours.taxon2))) %>%
  #dplyr::filter(!taxon == "Bradysia_nr.ocellaris") %>%
    ggplot(aes(x = position, y= RA, color = taxon, group=extract_type, shape=extract_type, fill=taxon)) +
    geom_hline(yintercept = 1, colour="black" )  +
    geom_line() +
    #geom_text(aes(label=paste0("x",round(RA, 1))),nudge_y=2, colour="black")+
    geom_ribbon(aes(ymax = (RA*SE^2), ymin=(RA/SE^2), colour=NULL), alpha=0.5) +
    geom_point() +
    scale_y_log10(breaks = c(0.01, 1, 100),
                  labels = trans_format("log10", math_format(10^.x))) +
    scale_color_manual(values = colours.taxon2) +
    scale_fill_manual(values = colours.taxon2) +
  facet_grid(taxon~target_subfragment)+ 
     labs(x = "Workflow step",
          y = "Relative abundance", 
          colour = "Taxon",
        title = "DNEasy")   +
  base_theme+
  theme(panel.grid.minor.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.border = element_blank(),
        axis.ticks  = element_line(colour = "grey20"),
        axis.line.y = element_line(),
        strip.text.y = element_blank(),
        legend.position = "none")

gg.ra_traj2 <- ra_traj %>%
  dplyr::filter(extract_type == "QuickExtract") %>%
  bind_rows(
    # Add dummy for missing bradysia
    ra_traj %>% filter(taxon == "Bradysia_nr.ocellaris") %>%
    mutate(RA = NA, SE = NA)
   ) %>%
    mutate(taxon = taxon %>% 
       str_replace("_", " ") %>%
       factor(levels = names(colours.taxon2))) %>%
    ggplot(aes(x = position, y= RA, color = taxon, group=extract_type, shape=extract_type, fill=taxon)) +
    geom_hline(yintercept = 1, colour="black")  +
    geom_line() +
    #geom_text(aes(label=paste0("x",round(RA, 1))),nudge_y=2, colour="black")+
    geom_ribbon(aes(ymax = (RA*SE^2), ymin=(RA/SE^2), colour=NULL), alpha=0.5) +
    geom_point() +
    scale_y_log10(breaks = c(0.01, 1, 100),
                  labels = trans_format("log10", math_format(10^.x))) +
    scale_color_manual(values = colours.taxon2) +
    scale_fill_manual(values = colours.taxon2) +
  facet_grid(taxon~target_subfragment)+ 
     labs(x = "Workflow step",
          y = "Relative abundance", 
          colour = "Taxon",
        title = "QuickExtract") +
  base_theme+
  theme(panel.grid.minor.y = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.border = element_blank(),
        axis.line.y = element_line(),
        axis.ticks  = element_line(colour = "grey20"),
        strip.text.y = element_blank(),
        legend.position = "none")
 

Fig4a <- gg.ra_traj2 + gg.ra_traj

Fig4 <- gg.bias_steps - Fig4a + plot_annotation(tag_levels = "A")

Fig4

#Save figure
pdf(file="figs/Fig4_bias_partitioned.pdf", width = 11, height = 8 , paper="a4r")
  plot(Fig4)
try(dev.off(), silent=TRUE)

```

# Trait effects

How do specimen traits affect its efficiency

```{r trait effects }
# Try predict on original bootstrappped one

# Add species traits
model_dat <- boot_partitioned %>%
  left_join(joint %>%
              ungroup()%>%
  #filter(target_subfragment=="fwhF2-fwhR2n") %>% # WHY SUBSET?
  mutate(primerdist = Fdist + Rdist) %>%
  dplyr::select(taxon, exoskeleton, biomass_mm3, surface_mm2, primerdist, `G|C`) %>%
    distinct()) %>%
  pivot_longer(starts_with("bias_"),
               names_to = c(".value", "step"),
               names_sep="_") %>%
  dplyr::rename(mixture_type = extract_type)

lm_mod <- linear_reg(mode = "regression") %>%
    set_engine("lm")

#create recipe
lm_rec <- model_dat %>%
  recipe(bias ~ exoskeleton + biomass_mm3 +  primerdist + `G|C`, data=model_dat) %>% #surface_mm2 +
  step_zv(all_numeric(), -all_outcomes()) %>%
  #step_corr(all_numeric(), -all_outcomes(), threshold = 0.9) %>%
  step_lincomb(all_numeric(), -all_outcomes()) %>%
  step_dummy(all_nominal(), one_hot=TRUE) %>%
  step_normalize(all_numeric(), -all_outcomes())%>%
  step_intercept(value = 0)

partition_boot_fit <- model_dat %>%
  #filter(id %in% c("Bootstrap0001", "Bootstrap0002","Bootstrap0003")) %>%
  #drop_na() %>%
  filter(!step == "seq") %>%
  group_by(step, mixture_type, id)  %>% 
  #slice_sample(n=5) %>% # For testing only
  nest() %>%
  mutate(models = purrr::map(data, function(y){
      model_workflow<- workflow() %>%
          add_model(lm_mod) %>%
          add_recipe(lm_rec)
      
      failed <<- y
      #Fit within each bootstrap
      model_workflow %>%
        fit(data = y) %>%
        extract_fit_parsnip()  
      }),
      coef_info = map(models, tidy)
  ) %>%
  unnest(coef_info) #%>%
 # dplyr::select(!where(is.list)) 

# Write out results to save time
saveRDS(partition_boot_fit, "output/rds/partition_boot_fit.rds")

# Read back in
partition_boot_fit <- readRDS("output/rds/partition_boot_fit.rds")

# Model diagnostics
partition_boot_fit %>%
  ggplot(aes(x = estimate))+
  geom_histogram() +
  facet_grid(step~mixture_type)

# Function to make p values
lmp <- function (modelobject) {
    if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
    f <- summary(modelobject)$fstatistic
    p <- pf(f[1],f[2],f[3],lower.tail=F)
    attributes(p) <- NULL
    return(p)
}

# Bootstrap estimates of model statistics
model_stats_boot <- partition_boot_fit %>% 
  dplyr::select(mixture_type, id, step, models) %>%
  distinct() %>%
  mutate(model_stats = purrr::map(models, function(x){
    fit <- summary(extract_fit_engine(x))
    tibble(
      f_stat = fit$fstatistic[1],
      numdf = fit$fstatistic[2],
      demdf = fit$fstatistic[3],
      rsq =fit$r.squared,
      adj_rsq = fit$adj.r.squared,
      p_val = lmp(extract_fit_engine(x)) 
    )
    }))%>%
  unnest_wider(model_stats) %>%
  drop_na() %>%
  group_by(step, mixture_type) %>% 
  dplyr::do(rsq = rsample:::pctl_single(.$rsq, alpha = 0.05),
            adj_rsq = rsample:::pctl_single(.$adj_rsq, alpha = 0.05),
            f_stat = rsample:::pctl_single(.$f_stat, alpha = 0.05),
            p_val = rsample:::pctl_single(.$p_val, alpha = 0.05)
            #,
            #numdf = unique(numdf),
            #demdf = unique(demdf)
            )  %>%
  unnest(rsq, adj_rsq, f_stat, p_val, names_sep = "")  %>%
  dplyr::select(-contains("method"), -contains("alpha"))  %>%
  mutate(signif = case_when(
    p_val.estimate < 0.05 ~ TRUE,
    TRUE ~ FALSE)
    )


partition_boot_pctl <- partition_boot_fit %>% 
  drop_na() %>%
  group_by(term, step, mixture_type) %>% 
  dplyr::do(rsample:::pctl_single(.$estimate, alpha = 0.05)) %>%
  dplyr::ungroup()

gg.bias_traits <- partition_boot_pctl %>%
  drop_na() %>%
  dplyr::mutate(term = term %>%
                  #str_replace("\\(Intercept\\)", "GC%") %>%
                  str_replace("\\(Intercept\\)", "Medium exoskeleton") %>%
                  str_replace("exoskeleton_hard", "Hard exoskeleton") %>%
                  str_replace("exoskeleton_soft", "Soft exoskeleton") %>%
                  str_replace("`G\\|C`", "GC%") %>%
                  str_replace("primerdist", "Primer mismatch") %>%
                  str_replace("biomass_mm3", "Biomass") %>%
                  str_replace("surface_mm2", "Surface Area") %>%
                  factor(levels = rev(c(
                    "Biomass",
                    "Surface Area",
                    "Soft exoskeleton",
                    "Medium exoskeleton",
                    "Hard exoskeleton",
                    "Primer mismatch",
                    "GC%")))) %>%
  mutate(step = step %>% 
           str_replace("all", "Total protocol bias") %>%
           str_replace("extract", "Extraction bias") %>%
           str_replace("PCR", "PCR bias") %>%
           str_replace("seq", "Sequencing + onward bias") %>%
           factor(levels = c(
             "Total protocol bias",
             "Extraction bias",
             "PCR bias",
             "Sequencing + onward bias"
             ))) %>%
  ggplot(aes(x=term, y=.estimate, colour=.estimate)) + 
  geom_hline(yintercept = 0, colour="grey40")+
  #stat_interval(aes(color_ramp  = stat(level)), colour = "skyblue")+
  stat_summary(fun = mean, size=0.2)+
  geom_pointrange(aes(ymax = .upper, ymin=.lower), colour = "skyblue")+
  #geom_interval(aes(ymax = estimate+std.error, ymin=estimate-std.error), colour = "skyblue") +
  facet_grid(mixture_type~step) + #, scales="free_x"
  coord_flip()+
  scale_color_viridis_c(option = "D")+
  scale_y_continuous(trans=pseudo_log_trans(1), breaks=c(-50, -15, -5, -1, 
                                                           1, 5, 15, 50))+
  #scale_color_distiller(palette="RdYlBu")+
  base_theme +
  theme(#panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.minor.x = element_blank(),
        axis.text.x = element_text(angle  = 0, hjust = 0.5),
        axis.ticks  = element_line(colour = "grey20"),
        #panel.border = element_blank(),
        legend.position = "none") + 
  labs(x = "Trait",
       y = "Regression coefficient")

gg.bias_traits

#Save figure
pdf(file="figs/Fig5_trait_effects_allmodels.pdf", width = 8, height = 5)
  plot(gg.bias_traits)
try(dev.off(), silent=TRUE)
```
